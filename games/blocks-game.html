<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BlockBuster Puzzle</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body {
            background: linear-gradient(135deg, #4f46e5, #ec4899, #22d3ee);
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            margin: 0;
            font-family: 'Press Start 2P', cursive;
            overflow: auto;
            position: relative;
        }
        body::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: url('https://www.transparenttextures.com/patterns/stardust.png');
            opacity: 0.15;
            z-index: -1;
            animation: bgShift 20s linear infinite;
        }
        @keyframes bgShift {
            0% { background-position: 0 0; }
            100% { background-position: 100% 100%; }
        }
        #game-container {
            background: rgba(255, 255, 255, 0.85);
            border-radius: 1.5rem;
            padding: 1rem;
            box-shadow: 0 12px 50px rgba(0, 0, 0, 0.4), 0 0 20px rgba(236, 72, 153, 0.5);
            max-width: 90vw;
            width: 100%;
            max-height: 90vh;
            overflow-y: auto;
            position: relative;
            animation: glow 2s ease-in-out infinite alternate;
            box-sizing: border-box;
            margin: 1rem 0;
        }
        @keyframes glow {
            from { box-shadow: 0 12px 50px rgba(0, 0, 0, 0.4), 0 0 20px rgba(236, 72, 153, 0.5); }
            to { box-shadow: 0 12px 50px rgba(0, 0, 0, 0.4), 0 0 30px rgba(236, 72, 153, 0.7); }
        }
        #game-canvas {
            border: 6px solid #1e40af;
            border-radius: 0.75rem;
            background: linear-gradient(#bae6fd, #e0f2fe);
            box-shadow: inset 0 0 15px rgba(0, 0, 0, 0.3);
            width: min(60vw, 60vh, 360px);
            height: min(60vw, 60vh, 360px);
            display: block;
        }
        .piece-canvas {
            border: 4px solid #1e3a8a;
            border-radius: 0.5rem;
            background: linear-gradient(#fefcbf, #fef08a);
            cursor: grab;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            width: min(12vw, 12vh, 50px);
            height: min(12vw, 12vh, 50px);
        }
        .piece-canvas:hover {
            transform: scale(1.12);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.4);
        }
        .piece-canvas.dragging {
            opacity: 0.75;
            transform: scale(1.2);
        }
        #drag-canvas {
            position: absolute;
            pointer-events: none;
            z-index: 10;
            width: min(12vw, 12vh, 50px);
            height: min(12vw, 12vh, 50px);
        }
        .highlight-cell {
            background: rgba(236, 72, 153, 0.6);
            animation: pulse 0.8s infinite;
        }
        @keyframes pulse {
            0% { opacity: 0.6; }
            50% { opacity: 0.9; }
            100% { opacity: 0.6; }
        }
        .action-button {
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            font-family: 'Press Start 2P', cursive;
            font-size: 0.8rem;
            color: white;
            border: none;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        .action-button:hover {
            transform: translateY(-4px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.4);
        }
        .action-button:active {
            transform: translateY(0);
        }
        .rotate-button {
            background: linear-gradient(45deg, #10b981, #34d399);
            padding: 0.5rem;
            border-radius: 0.5rem;
            font-size: 1rem;
            cursor: pointer;
            transition: transform 0.2s ease;
            line-height: 1;
        }
        .rotate-button:hover {
            transform: scale(1.1);
        }
        #game-over, #tutorial {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(17, 24, 39, 0.9);
            padding: 2rem;
            border-radius: 1rem;
            text-align: center;
            color: #f3f4f6;
            animation: slideIn 0.5s ease;
            z-index: 20;
            max-width: 80vw;
        }
        @keyframes slideIn {
            from { transform: translate(-50%, -60%); opacity: 0; }
            to { transform: translate(-50%, -50%); opacity: 1; }
        }
        #game-over img, #tutorial img {
            width: 100px;
            margin-bottom: 1rem;
        }
        #score {
            background: rgba(0, 0, 0, 0.1);
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            display: inline-block;
            font-size: 1rem;
        }
        footer {
            margin-top: 1rem;
            font-size: 0.6rem;
            color: #6b7280;
            opacity: 0.8;
        }
        .tooltip {
            position: relative;
        }
        .tooltip:hover::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: #1e3a8a;
            color: white;
            padding: 0.5rem;
            border-radius: 0.25rem;
            font-size: 0.6rem;
            white-space: nowrap;
            z-index: 10;
        }
        .emoji-decoration {
            position: absolute;
            font-size: 1.5rem;
            opacity: 0.3;
            pointer-events: none;
        }
        #emoji-top-left { top: 0.5rem; left: 0.5rem; }
        #emoji-top-right { top: 0.5rem; right: 0.5rem; }
        #emoji-bottom-left { bottom: 0.5rem; left: 0.5rem; }
        #emoji-bottom-right { bottom: 0.5rem; right: 0.5rem; }
        .button-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 0.5rem;
            margin-top: 0.5rem;
            padding-bottom: 0.5rem;
        }
        .piece-container {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.5rem;
        }
        #next-pieces {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            margin-left: 1rem;
        }
        .game-area {
            display: flex;
            justify-content: center;
            align-items: flex-start;
            gap: 1rem;
        }
    </style>
</head>
<body>
    <div id="game-container" class="text-center">
        <h1 class="text-3xl font-bold text-pink-500 mb-4 drop-shadow-lg">BlockBuster Puzzle üéÆ</h1>
        <div id="score" class="text-lg font-semibold text-indigo-900 mb-4">Score: 0</div>
        <div class="game-area">
            <canvas id="game-canvas" class="mx-auto"></canvas>
            <div id="next-pieces">
                <div class="piece-container">
                    <canvas id="piece1" class="piece-canvas"></canvas>
                    <button class="rotate-button tooltip" data-tooltip="Rotate piece" onclick="rotatePiece(0)">üîÑ</button>
                </div>
                <div class="piece-container">
                    <canvas id="piece2" class="piece-canvas"></canvas>
                    <button class="rotate-button tooltip" data-tooltip="Rotate piece" onclick="rotatePiece(1)">üîÑ</button>
                </div>
                <div class="piece-container">
                    <canvas id="piece3" class="piece-canvas"></canvas>
                    <button class="rotate-button tooltip" data-tooltip="Rotate piece" onclick="rotatePiece(2)">üîÑ</button>
                </div>
            </div>
        </div>
        <div class="button-container">
            <button class="action-button bg-blue-600 tooltip" data-tooltip="Undo last move" onclick="undoMove()"><span>üîÑ</span> Undo</button>
            <button class="action-button bg-red-600 tooltip" data-tooltip="Clear the board" onclick="clearBoard()"><span>üóëÔ∏è</span> Clear</button>
            <button class="action-button bg-purple-600 tooltip" data-tooltip="Start a new game" onclick="restartGame()"><span>üöÄ</span> Restart</button>
            <button class="action-button bg-green-600 tooltip" data-tooltip="Get a suggested move" onclick="getHint()"><span>üí°</span> Hint</button>
        </div>
        <footer>Powered by xAI | Inspired by CrazyGames üïπÔ∏è</footer>
        <div class="emoji-decoration" id="emoji-top-left">üé≤</div>
        <div class="emoji-decoration" id="emoji-top-right">üß©</div>
        <div class="emoji-decoration" id="emoji-bottom-left">üéÆ</div>
        <div class="emoji-decoration" id="emoji-bottom-right">üåü</div>
    </div>
    <div id="game-over">
        <img src="https://media.giphy.com/media/l0Iyl55kTeh71nTWw/giphy.gif" alt="Game Over Cartoon GIF">
        <h2 class="text-xl mb-4">Game Over! üòµ</h2>
        <p class="mb-4">Your Score: <span id="final-score">0</span></p>
        <button class="action-button bg-purple-600" onclick="restartGame()">Play Again üöÄ</button>
    </div>
    <div id="tutorial">
        <img src="https://media.giphy.com/media/3o7btPCcdNniyf0ArS/giphy.gif" alt="Tutorial Cartoon GIF">
        <h2 class="text-lg mb-4">How to Play üïπÔ∏è</h2>
        <p class="mb-4 text-sm">Drag pieces to the grid to fill rows or columns. Click üîÑ to rotate pieces. Clear lines to score points! üåü</p>
        <button class="action-button bg-green-600" onclick="closeTutorial()">Got It! ‚úÖ</button>
    </div>
    <canvas id="drag-canvas" class="hidden"></canvas>
    <script>
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        const pieceCanvases = [
            document.getElementById('piece1'),
            document.getElementById('piece2'),
            document.getElementById('piece3')
        ];
        const pieceCtxs = pieceCanvases.map(canvas => canvas.getContext('2d'));
        const dragCanvas = document.getElementById('drag-canvas');
        const dragCtx = dragCanvas.getContext('2d');
        const scoreDisplay = document.getElementById('score');
        const gameOverScreen = document.getElementById('game-over');
        const finalScoreDisplay = document.getElementById('final-score');
        const tutorialScreen = document.getElementById('tutorial');
        const GRID_SIZE = 10;
        let CELL_SIZE;
        let PIECE_SIZE;
        const COLORS = ['#f87171', '#34d399', '#60a5fa', '#a78bfa', '#facc15'];
        let grid = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(0));
        let pieces = [];
        let selectedPiece = null;
        let selectedIndex = null;
        let score = 0;
        let moveHistory = [];
        let isDragging = false;
        let dragOffsetX = 0;
        let dragOffsetY = 0;
        const SHAPES = [
            [[1, 1], [1, 1]], // Square
            [[1, 1, 1]], // Line (horizontal)
            [[1], [1], [1]], // Line (vertical)
            [[1, 1], [0, 1]], // L-shape
            [[1, 0], [1, 1]], // Reverse L
            [[1, 1, 1], [0, 1, 0]] // T-shape
        ];
        function resizeCanvas() {
            const maxSize = Math.min(window.innerWidth * 0.6, window.innerHeight * 0.6, 360);
            canvas.width = maxSize;
            canvas.height = maxSize;
            CELL_SIZE = maxSize / GRID_SIZE;
            PIECE_SIZE = Math.min(window.innerWidth * 0.12, window.innerHeight * 0.12, 50);
            pieceCanvases.forEach(pc => {
                pc.width = PIECE_SIZE;
                pc.height = PIECE_SIZE;
            });
            dragCanvas.width = PIECE_SIZE;
            dragCanvas.height = PIECE_SIZE;
            drawGrid();
            updatePieces();
        }
        function generatePiece() {
            const shape = SHAPES[Math.floor(Math.random() * SHAPES.length)];
            const color = COLORS[Math.floor(Math.random() * COLORS.length)];
            return { shape: shape.map(row => [...row]), color };
        }
        function rotatePiece(index) {
            if (index < 0 || index >= pieces.length) return;
            const piece = pieces[index];
            const oldShape = piece.shape;
            const rows = oldShape.length;
            const cols = oldShape[0].length;
            const newShape = Array(cols).fill().map(() => Array(rows).fill(0));
            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    newShape[j][rows - 1 - i] = oldShape[i][j];
                }
            }
            piece.shape = newShape;
            drawPiece(pieceCtxs[index], piece, 4, 4, PIECE_SIZE / 3);
        }
        function drawGrid(highlightCells = []) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            for (let i = 0; i < GRID_SIZE; i++) {
                for (let j = 0; j < GRID_SIZE; j++) {
                    ctx.strokeStyle = '#1e40af';
                    ctx.strokeRect(j * CELL_SIZE, i * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                    if (grid[i][j]) {
                        ctx.fillStyle = grid[i][j];
                        ctx.fillRect(j * CELL_SIZE + 2, i * CELL_SIZE + 2, CELL_SIZE - 4, CELL_SIZE - 4);
                        ctx.strokeStyle = '#1e3a8a';
                        ctx.strokeRect(j * CELL_SIZE + 2, i * CELL_SIZE + 2, CELL_SIZE - 4, CELL_SIZE - 4);
                    }
                    if (highlightCells.some(cell => cell.row === i && cell.col === j)) {
                        ctx.fillStyle = 'rgba(236, 72, 153, 0.6)';
                        ctx.fillRect(j * CELL_SIZE, i * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                    }
                }
            }
        }
        function drawPiece(ctx, piece, x, y, cellSize) {
            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
            for (let i = 0; i < piece.shape.length; i++) {
                for (let j = 0; j < piece.shape[i].length; j++) {
                    if (piece.shape[i][j]) {
                        ctx.fillStyle = piece.color;
                        ctx.fillRect(x + j * cellSize + 2, y + i * cellSize + 2, cellSize - 4, cellSize - 4);
                        ctx.strokeStyle = '#1e3a8a';
                        ctx.strokeRect(x + j * cellSize + 2, y + i * cellSize + 2, cellSize - 4, cellSize - 4);
                    }
                }
            }
        }
        function updatePieces() {
            while (pieces.length < 3) {
                pieces.push(generatePiece());
            }
            pieces.forEach((piece, index) => {
                drawPiece(pieceCtxs[index], piece, 4, 4, PIECE_SIZE / 3);
            });
            checkGameOver();
        }
        function canPlacePiece(piece, row, col) {
            for (let i = 0; i < piece.shape.length; i++) {
                for (let j = 0; j < piece.shape[i].length; j++) {
                    if (piece.shape[i][j]) {
                        if (row + i >= GRID_SIZE || col + j >= GRID_SIZE || grid[row + i][col + j]) {
                            return false;
                        }
                    }
                }
            }
            return true;
        }
        function getHighlightCells(piece, row, col) {
            const cells = [];
            for (let i = 0; i < piece.shape.length; i++) {
                for (let j = 0; j < piece.shape[i].length; j++) {
                    if (piece.shape[i][j]) {
                        cells.push({ row: row + i, col: col + j });
                    }
                }
            }
            return cells;
        }
        function placePiece(piece, row, col) {
            const move = { piece: { shape: piece.shape.map(row => [...row]), color: piece.color }, row, col, clearedLines: [] };
            for (let i = 0; i < piece.shape.length; i++) {
                for (let j = 0; j < piece.shape[i].length; j++) {
                    if (piece.shape[i][j]) {
                        grid[row + i][col + j] = piece.color;
                    }
                }
            }
            moveHistory.push(move);
            checkLines();
            pieces.splice(pieces.indexOf(piece), 1);
            updatePieces();
            drawGrid();
        }
        function checkLines() {
            let linesCleared = 0;
            for (let i = 0; i < GRID_SIZE; i++) {
                if (grid[i].every(cell => cell !== 0)) {
                    grid[i].fill(0);
                    linesCleared++;
                    moveHistory[moveHistory.length - 1].clearedLines.push(i);
                }
            }
            for (let j = 0; j < GRID_SIZE; j++) {
                if (grid.every(row => row[j] !== 0)) {
                    for (let i = 0; i < GRID_SIZE; i++) {
                        grid[i][j] = 0;
                    }
                    linesCleared++;
                    moveHistory[moveHistory.length - 1].clearedLines.push(j);
                }
            }
            if (linesCleared > 0) {
                score += linesCleared * 100;
                if (linesCleared > 1) score += 50;
                scoreDisplay.textContent = `Score: ${score}`;
                drawGrid();
                canvas.classList.add('animate-pulse');
                setTimeout(() => canvas.classList.remove('animate-pulse'), 500);
                const lineClear = document.createElement('img');
                lineClear.src = 'https://media.giphy.com/media/26gR0YFIlQNrtQz5K/giphy.gif';
                lineClear.style.position = 'absolute';
                lineClear.style.top = '50%';
                lineClear.style.left = '50%';
                lineClear.style.transform = 'translate(-50%, -50%)';
                lineClear.style.width = '120px';
                lineClear.style.zIndex = '15';
                document.getElementById('game-container').appendChild(lineClear);
                setTimeout(() => lineClear.remove(), 1000);
            }
        }
        function checkGameOver() {
            if (pieces.every(piece => {
                for (let i = 0; i < GRID_SIZE; i++) {
                    for (let j = 0; j < GRID_SIZE; j++) {
                        if (canPlacePiece(piece, i, j)) {
                            return false;
                        }
                    }
                }
                return true;
            })) {
                gameOverScreen.style.display = 'block';
                finalScoreDisplay.textContent = score;
            }
        }
        function undoMove() {
            if (moveHistory.length === 0) return;
            const lastMove = moveHistory.pop();
            for (let i = 0; i < lastMove.piece.shape.length; i++) {
                for (let j = 0; j < lastMove.piece.shape[i].length; j++) {
                    if (lastMove.piece.shape[i][j]) {
                        grid[lastMove.row + i][lastMove.col + j] = 0;
                    }
                }
            }
            pieces.unshift(lastMove.piece);
            if (pieces.length > 3) pieces.pop();
            updatePieces();
            drawGrid();
        }
        function clearBoard() {
            grid = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(0));
            moveHistory = [];
            score = 0;
            scoreDisplay.textContent = `Score: ${score}`;
            pieces = [];
            gameOverScreen.style.display = 'none';
            updatePieces();
            drawGrid();
        }
        function restartGame() {
            clearBoard();
            updatePieces();
            gameOverScreen.style.display = 'none';
        }
        function getHint() {
            for (let index = 0; index < pieces.length; index++) {
                const piece = pieces[index];
                for (let i = 0; i < GRID_SIZE; i++) {
                    for (let j = 0; j < GRID_SIZE; j++) {
                        if (canPlacePiece(piece, i, j)) {
                            const highlightCells = getHighlightCells(piece, i, j);
                            drawGrid(highlightCells);
                            pieceCanvases[index].classList.add('animate-pulse');
                            setTimeout(() => {
                                pieceCanvases[index].classList.remove('animate-pulse');
                                drawGrid();
                            }, 2000);
                            return;
                        }
                    }
                }
            }
        }
        function closeTutorial() {
            tutorialScreen.style.display = 'none';
        }
        pieceCanvases.forEach((canvas, index) => {
            canvas.addEventListener('mousedown', (e) => {
                if (pieces[index]) {
                    selectedPiece = pieces[index];
                    selectedIndex = index;
                    isDragging = true;
                    dragCanvas.classList.remove('hidden');
                    pieceCanvases[index].classList.add('dragging');
                    const rect = canvas.getBoundingClientRect();
                    dragOffsetX = e.clientX - rect.left - PIECE_SIZE / 2;
                    dragOffsetY = e.clientY - rect.top - PIECE_SIZE / 2;
                    drawPiece(dragCtx, selectedPiece, 0, 0, PIECE_SIZE / 3);
                    updateDragPosition(e);
                }
            });
        });
        document.addEventListener('mousemove', (e) => {
            if (isDragging && selectedPiece) {
                updateDragPosition(e);
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                const row = Math.floor(y / CELL_SIZE);
                const col = Math.floor(x / CELL_SIZE);
                let highlightCells = [];
                if (x >= 0 && x < canvas.width && y >= 0 && y < canvas.height && canPlacePiece(selectedPiece, row, col)) {
                    highlightCells = getHighlightCells(selectedPiece, row, col);
                }
                drawGrid(highlightCells);
            }
        });
        document.addEventListener('mouseup', (e) => {
            if (isDragging && selectedPiece) {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                const row = Math.floor(y / CELL_SIZE);
                const col = Math.floor(x / CELL_SIZE);
                if (x >= 0 && x < canvas.width && y >= 0 && y < canvas.height && canPlacePiece(selectedPiece, row, col)) {
                    placePiece(selectedPiece, row, col);
                }
                isDragging = false;
                selectedPiece = null;
                selectedIndex = null;
                dragCanvas.classList.add('hidden');
                pieceCanvases.forEach(canvas => canvas.classList.remove('dragging'));
                drawGrid();
            }
        });
        function updateDragPosition(e) {
            const x = e.clientX - dragOffsetX;
            const y = e.clientY - dragOffsetY;
            dragCanvas.style.left = `${x}px`;
            dragCanvas.style.top = `${y}px`;
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
        drawGrid();
        updatePieces();
        tutorialScreen.style.display = 'block';
    </script>
</body>
</html>